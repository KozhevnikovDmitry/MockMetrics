* MM алгоритм разбора модульного теста:
1) Обрабатываем аргументы модульного теста
	1.1)
2) Обрабатываем тело теста как блок кода
3) Проводим постобработку снапшота

* ММ алгоритм разборка блока кода
1) Для каждого прямого потомка блока делаем:
	1.1) Если потомок это объявление  - обрабатываем как объявление
	1.2) Если потомок это утверждение(Statement) - обрабатываем как утверждение
		
* MM алгоритм разбора объявления
1) Если это объявление константы - запоминаем объявление в стабы
2) Если это объявление локальной переменной - запоминаем объявление а локальные переменные и обрабатываем как локальную переменную
		
* ММ алгоритм разбора локальной переменной:
1) Если переменная является Moq стабом - обрабатываем как стаб
2) Если переменная является Moq моком - обрабатываем как мок
3) Если переменная имеет примитивный тип - обрабатываем как примитивную переменную
4) Если переменная имеет ссылочный тип - обрабатываем как переменную ссылочного типа

* ММ алгоритм разбора Moq стаба
1) Записываем в стабы
2) Обрабатываем аргументы вызова Of:
	2.1) Обрабатываем левую часть
		2.1.1) Если в левой части стоит свойство - записываем в настроки стаба
		2.1.2) Если в левой части вызов метода - записываем в настройки стаба и обрабатываем аргументы как подчинённые выражения
	2.2) Обрабатываем правую часть как подчинённое выражение

*  алгоритм разбора Moq мока
1) Записываем в моки
2) Обрабатываем аргументы вызова конструктора Mock
	2.1) Если указано MockBehavior, запоминаем его для мока
	2.2) Если не указано, запоминаем MockBehavior.Default
	2.3) Остальные аргументы обрабатываем как подчинённые выражения

* ММ алгоритм разбора примитивной переменной
1) Обрабатываем выражение инициализации переменной:
	1.1) Если выражение является литералом - записываем переменную в стаб
	1.2) Если выражение содержит вызов ранее обяъвленного таргета - записываем переменную в результат проверки
	1.3) Если выражением не содержит вызовов ранее объявленного таргета - записываем в стабы
2) Обрабатываем выражение инициализации переменной как подчинённое выражение

* ММ алгоритм разбора ссылочной переменной(не является Moq стабом, Moq моком)
1) Обрабатываем выражение инициализации переменной:
	1.1) Если выражение является вызовом конструктора - записываем в таргеты
	1.2) Если выражение содержит вызов таргета - записываем в результаты проверки
	1.3) Если для переменной делаются вызовы или она или её свойства участвуют в проверках - записываем в таргеты	

* MM алгоритм разбора утверждения(Statement)
1) Если утверждение является объявлением - обрабатываем как объявление
2) Если утверждение является отдельным выражением - обрабатываем как отдельное утверждение
3) Если утверждение является управляющей конструкцией обрабатываем согласно структуре конструкции

* MM алгоритм разбора подчинённого выражения
1) Если выражение - литерал - записываем в стаб-выражения
2) Если выражение - typeof - обрабатываем выражение внутри typeof как подчинённое выражение
3) Если выражение является доступом по индексу
	3.1) Обрабатываем выражение получения массива как подчинённое выражение
	3.2) Обрабатывает выражение получения индекса как подчинённое выражение
4) Если выражение является приведением типа - обрабатываем приводимое выражение как подчинённое выражение
5) Если выражение is(as) записываем в стаб-выражения тип приведения и обрабатываем приводимое выражение как подчинённое выражение
6) Если выражения являтся тернарным условием(?: или ??:) обрабатываем подвыражения как полчинённые выражения
7) Если выражение является префиксным или постфиксным оператором - обрабатываем операнд-выражение как подчинённое выражение
8) Если выражение является бинарным - обрабатываем обе части как подчинённые выражения
9) Если выражение является унарным оператором - обрабатываем выражение внутри оператора как подчинённое
10) Если выражение является выражением создания
	10.1) Если выражение создаёт объект
		10.1.1) Если создаётся Mock - записываем выражение в mock-выражение, обрабатываем аргументы вызова конструктора Mock
		10.1.2) Если создаётся примитивный тип - записываем в стаб-вызовы, обрабатываем аргументы вызова конструктора
		10.1.3) Если создаётся анонимный тип - записываем в стаб-вызовы, обрабатываем поля анонимного типа как объявления
		10.1.4) Если создаётся ссылочный тип - записываем в таргет-вызовы, обрабатываем аргументы вызова конструктора
	11.2) Если выражение создаём массив
		11.2.1) Записываем в стаб-вызовы
		11.2.2) Обрабатываем выражение задающее размер массива как подчинённое выражение
		11.2.3) Обрабатываем все выражения в инициализаторе массива как подчинённые выражения
12) Если выражение является анонимной функцией(лямбда выражение или анонимный метод) 
	12.1) Записываем в стабы её,
	12.2) Записываем в стабы аргументы функции 
	12.3) Обрабатываем тело функции как подчинённое выражение или как утверждение
13) Если выражение является ссылкой
	13.1)
14) Если выражение является вызовом
	14.1)
15) Если выражение является запросом


















